# 安全框架和实践

1. 安全需求-安全设计-安全实现-安全测试-安全发布与部署




# CleanCode与重构

## CleanCode定义
1. 简洁/可读
    - 软件适应变化易于阅读的能力：易于阅读、易于实现、恰到好处
    - 名称和格式传递有用信息
    - 减少信息误解、减少信息干扰、减少理解难度

2. 代码可维护
    - 高内聚、低耦合；隔离不同变化、耦合点稳定
    - SOIDL原则

3. 代码可测试
    - 可隔离、可控制、可观测、可定位

4. 代码可靠
    - 代码可靠性：给定时间间隔和环境条件下，按设计要求成功运行程序的概率
    - 预防、容错、自愈

5. 代码高效
    - 尽量少的使用系统资源：CPU、内存、硬盘、网络带宽等
    - 高效算法、减少冗余计算

6. 代码可移植
    - 适应不同环境的能力

7. 代码安全
    - 减少代码攻击面：减少外部交互
    - 输入检验及转义
    - 采用防御式编程策略
    - 易出现在：字符串操作、格式化输出、内存管理、整型操作、文件操作等

8. 权衡：安全>可靠>可读>可维护>可测试>高效>可移植


## CleanCode评估方法
1. 专家评估+工具评估

2. 专家评估方法：WTF

3. 工具评估方法：代码编写（IDE检查）-代码检视（门禁）-版本级（发布）

## CleanCode达成方法
1. 设计与TDD

2. 代码重构

3. 工具检查

4. 专家评估


## 软件重构的概念与原则

### 什么是重构
不改变代码外在行为，改进程序内部结构。

1. 为何重构：
    - 改进软件设计
    - 软件更易被理解
    - 帮助找到bug
    - 提高编程速度

2. 重构分类
    - 小粒度重构：函数级、小模块级
    - 大粒度重构：架构级、大模块级


### 什么时候重构

应该随时随地进行。

1. 重构时机：
    - 添加功能
    - 修补错误
    - 复审代码


2. 什么时候不适合做重构
    - 代码太混乱、设计完全错误、还不如重写
    - 明天就是ddl，不要做“最后一分钟的修改”
    - 重构工作量显著-->推迟重构
    - 没有更好思路，不可重构

3. 重构的陷阱
    - 七零八碎，无法复原
    - 分支开发，难以集成
    - 半途而废，迷途难反
    - 孤注一掷，进退两难

### 如何重构

1. 添加新功能 与 重构 不同时，一次只做一件事。

2. 重构流程：
    - 测试保护-识别坏味道-采用手法-小步前进（改一块提交一块）
    - 小步前进-随时可用-随时可停-随时回退