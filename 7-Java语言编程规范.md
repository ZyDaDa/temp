
代码要求：可读、可维护、安全、可靠、可测试、高效、可移植

# 代码风格

![alt text](images/image.png)

1. 常量：不可被修改的静态的filed和枚举常量。
    - 命名表达完整语义
    - 避免使用魔鬼数字
    - 推荐就近定义常量
    - mutable对象禁止定义为常量

2. 注释：
    - 总体原则：按需注释
    - 代码注释：非首行添加空行，注释符和内容之间至少留一个空格，交付代码不要有todo等

3. 源文件排版：版权、package、import、顶层类顺序，用空行分隔
    - import：安卓、其他商业组织、其他开源第三方、net/org开源组织
    - 类：类变量、静态初始化、实例变量、实力初始化、构造方法、方法

4. 大括号：K&R风格
    - 左不换行、右单独一行
    - 右大括号可以跟逗号、分号、else、catch等关键字

5. 行宽：不超过120个字符

6. 换行：操作符、连接符放在新一行

7. 水平空格只能使用单个空格或多个空格组合
    - 缩进使用四个空格
    - 关键字或有大括号，二元/三元运算符类似运算符两侧
    - 行尾和空行不用空格
    - 不用空格保持垂直对齐

8. 字面量使用合理的后缀指定数值类型：
    - float： `3.14F`or `3.14f`
    - double: `3.14D` or `3.14d`
    - long: `500L`

    - 较大的数字使用下划线分隔 `300_000_000L`

# 编程实践

## 声明和初始化
1. 局部变量、累的成员变量 一行只能声明一个变量
2. 数组声明：不要使用c风格。正确的`String[] args = ...`

## 数据类型

1. 整数溢出：
    - 预先检查，保证预算不会出现溢出
    - 使用Math类安全方法
    - 向上类型转换或BigInteger进行运算。

2. 浮点数：
    - 不要使用浮点进行精确计算
    - 不要对浮点数进行等值判断
    - 不要用浮点数作为HashMap的key

3. 字符串：
    - 注意不同系统的换行符、文件路径。不要硬编码，换行符使用`System.lineSeparator()`获取, 路径分隔符使用Java.io.File中的separator。
    - 注意大小写转换、字符与字节转换明确指定编码格式。
    - 敏感数据清理：主动清理内存。 `Arrys.fill(value, (char) 0x00);`

4. 包装类型使用
    - 注意大量隐含拆装箱操作
    - 优先使用基本类型
    - 包装类型使用`equals()`、`compareTo()`等比较，不要使用`==`

5. 混合运算中避免隐式类型转换

## 表达式、控制语句

1. 优先级容易混淆的，或涉及位运算操作推荐使用括号明确运算顺序
2. 禁止使用直接为Null的对象
    - 代码中通过预检查消除空指针
3. 代码中不应该有断言。
4. 避免分支遗漏：
    - 使用else或default分支进行兜底

## 方法
1. 方法设计精髓：低耦合高内聚的简洁方法
    - 契约设计、防御式编程，编写安全可靠的代码
    - 方法设计合适的返回值
    - 对于Native方法要对齐进行封装
    - 优先使用成熟的API
    - 不要使用已经标注为 @Deprecated 的方法

2. 方法要简短
    - 方法行数不超过50
    - 参数不超过5个
        - 相关参数合并为类
        - 构造方法参数过多使用Build或工厂模式
    - 嵌套层数不要超过4，可以使用卫语句降低嵌套层数
    - 抛出异常不建议唱过五类

3. 合理设计返回值消减NullPointerException
    - 数组返回长度为0数组
    - 集合返回空集合
    - 其他推荐使用Optional替代null作为返回值

## 类、接口、面向对象
1. 概述
    - 类为其成员设置最小可访问性
    - 类中避免定义public且非final的属性
    - 匿名类可以使用Lambda表达式或方法引用替代
    - 覆写equals时同时覆写hashCode方法
    - 方法重载时变基本类型与封装类型重载
    - 静态方法或属性使用类名调用
    - 接口中的方法、属性定义不适用多余修饰词

2. 几个概念
    - 覆写：父类中的实例方法被其子类重新实现
    - 重载：同一个类，名字相同参数列表不同
    - 隐藏：一个类中的属性、静态方法、内部类可以隐藏父类中相同名字的
    - 遮蔽：一个变量、方法、类可以遮蔽类内部同名的变量、方法、类
    - 遮掩：一个变量可以遮掩具有相同名字的类，变量或类型可以遮掩一个包

3. 不要在父类的构造中调用可能被子类重写的方法

4. 正确实现单例模式
    - 构造方法设为私有
    - 防止对象在初始化被多个线程同时运行
    - 确保对象不可序列化
    - 确保对象无法克隆

## 异常处理

1. 受检异常：可容错处理、能合理恢复程序运行的场景
2. 运行时异常：编程错误
3. 不要使用空的catch块忽略异常 
    - 释放资源类操作发生的异常可以被忽略

4. 不要直接捕获Throwable、Exception、RuntimeException
    - 要捕获具体的子类异常。例外：三方api直接抛出Exception；兜底事件处理

5. 敏感数据保护：对于抛出到信任边界之外的异常，需要进行敏感信息过滤

6. 在catch块中抛出新异常时，避免丢失原始信息。
    - 可以将原始异常记录到日志，然后抛出新异常


## 并发与多线程
1. 原子性与可见性
    - 原子性：一个操作或多个操作，要么全部执行，要么都不执行。可以通过`synchronized`和`Lock`保证原子性
    - 可见性：多个线程访问一个变量，一个线程修改，其他线程可以立即看到。可以使用`volatile`关键字来保证可见性，通过`synchronized`和`Lock`也能保证可见性。

2. 避免数据竞争：建立happen-before关系
    - 考虑使用队列（如BlockingQueue）或其他高级同步机制(如executor、future等)
    - 考虑使用锁来保护共享变量

3. 死锁
    - 异常时导致未释放锁
    - 请求的锁和释放顺序不当：
        - 使用高层并发对象的内置锁进行同步
        - 使用实例锁来同步静态共享变量
        - 使用可被重用的对象进行同步
        - 使用getClass() 返回的类对象进行同步
    - 阻塞操作中持有锁

4. 避免使用不正确的双重检查锁（延迟初始化单例）

5. 线程API：注意问题
    - 创建新线程需要吃定线程名称
    - 注册线程对象异常处理handler
    - 不依赖线程调度器、线程优先级和yield()方法
    - 使用合理的方法来中断线程
        - 禁止使用`Thread.stop()`方法终止线程
        - 线程中断由业务代码来协作完成，慎用`Thread.interrupt()`
        - 优先使用协作式的线程同步机制来通知一个线程终止作业
        - 线程应周期性检查自己是否被终止

6. 线程池中的任务结束后必须清理自定义的ThreadLocal变量。


7. 其他
    - 锁考虑性能损耗，缩小加锁范围
    - 高并发防止使用`==`被击穿
    - 使用`lock.tryLock()`来尝试获取锁时，按是否成功获取到锁进行对应的业务逻辑处理
    - 不推荐使用ThreadGroup
    - 优先使用不可变对象在多线程间传递信息

## 泛型和集合

1. 集合中优先使用泛型
2. 使用`Collectors.toMap()`方法时，当出现相同key或value为null时会抛出异常。
3. 使用`Arrays.asList()`方法将数组转为集合时，生成的集合不支持添加、删除操作；对数组或集合中的元素进行修改会同步更新。
4. `Collections`类生成的immutable的set、List、Map不能添加、删除
5. 调用List的`subList()`方法生成的子`List`与原List存在关联关系
6. 应保证集合的`addAll()`方法传入的集合不为null

7. 方法设计可以优先考虑泛型：代码简洁、最大限度重用代码、保护类型安全
    - 静态方法如果需要使用泛型必须定义成泛型方法
8. 要使用泛型集合而不是数组

## 输入和输出

1. 目录遍历攻击：攻击者通过输入包含'上一层目录'攻击
    - 使用不可信数据构造文件路径时，需要进行严格校验和过滤
    - 文件路径标准化处理，使用`getCanonicalPath()`
2. 对zip文件解压时，边度边统计实际解压文件大小以及文件数，确保zip解压不消耗过多文件资源

3. 临时文件使用完毕必须及时删除

## 序列化
1. 非静态内部容器类不应该实现序列化操作
2. 禁止直接序列化指向系统资源的信息
3. 为了防止敏感信息泄露可以对敏感信息进行数字签名、加密

4. Json格式反序列：
    - 禁止auto Type功能
    - 对目标class进行白名单检查

5. XML格式：
    - 对目标class白名单检查
    - 使用三方件的安全设置


## 外部数据校验

1. 总体原则：所有外部数据使用前要进行合法性校验
2. 校验步骤：  标准化-输入清理-校验
    - 标准化： 将输入转为预期的最简形式
    - 输入清理： 删除、替换不期望的字符
    - 校验： 白名单校验优先

3. SQL注入
    - 使用参数化查询（预编译）
    - 验证输入
    - 转码

4. 命令注入：类似于SQL注入
    - 使用jdk的api代替执行命令
    - 输入校验
    - 转码

5. 正则注入：
    - 严格限制用户输入长度限制
    - 不要使用过于复杂的正则
    - 减少分组使用量
    - 避免动态构造正则
    - 白名单检查外部输入动态构造正则

6. 不安全反射
    - 对外部数据白名单校验
    - 让用户在指定范围内选择方式进行防护



## 日志
1. 日志注入:
    - 白名单校验：禁止使用\r\n换行符
    - 长度限制

2. 敏感信息泄露
    - 口令、秘钥等使用**替代
    - 其他敏感信息使用匿名化处理

## 性能和资源管理

1. 提升数组相关操作
    - 集合转为数组时使用`Collection<T>.toArray(T[])`
    - 数组复制使用`System.arraycopy()`或`Arrays.copyOf()`

2. 集合初始化时，如果课预估集合元素数量，应指定初始化大小
    - 防止扩容的性能损耗

3. 避免对正则表达式重复编译，提前对正则表达式预编译
4. 避免创建不必要的对象，不要创建临时变量作为return返回值
5. 在try-with-resource或finally里释放IO类资源
6. 禁止主动使用GC或使用`finalize()`方法

## 其他
1. 随机数：对于敏感操作，使用安全随机数
    - 真随机数：Linux的`/dev/random`设备接口或Windows的`CryptGenRandom()`接口
    - 使用真随机数作为种子生成伪随机数

2. 传递敏感信息时应该使用SSLSocket
3. 代码中不使用的代码应该直接删除，不要注释掉

4. 代码中禁止包含公网地址